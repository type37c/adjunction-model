# Step 1 問題診断：ηが不変である根本原因

**診断日**: 2026-02-19  
**問題**: 全1,920データポイントでηが完全に同一（0.025155）

---

## 1. Phase 1の訓練データ前処理の確認結果

### 1.1. Phase 1の点群生成方法

`SyntheticAffordanceDataset`（`src/data/synthetic_dataset.py`）を確認した結果：

```python
def _generate_shape(self, shape_type: int, num_points: int):
    if shape_type == 0:  # Cube
        points = np.random.uniform(-1, 1, (num_points, 3))
    
    elif shape_type == 1:  # Cylinder
        theta = np.random.uniform(0, 2 * np.pi, num_points)
        r = np.random.uniform(0, 1, num_points)
        z = np.random.uniform(-1, 1, num_points)
        x = r * np.cos(theta)
        y = r * np.sin(theta)
        points = np.stack([x, y, z], axis=-1)
    
    elif shape_type == 2:  # Sphere
        # ... (similar pattern)
```

**重要な発見**:
- Phase 1の訓練データは**すでに正規化されている**（範囲: [-1, 1]）
- 立方体、円柱、球はすべて同じスケール範囲内で生成される
- **追加の正規化は行われていない**

### 1.2. Phase 1の訓練パラメータ

- **点の数**: 512点（`num_points=512`）
- **形状**: 立方体（0）、円柱（1）、球（2）
- **訓練サンプル数**: 100
- **検証サンプル数**: 20

---

## 2. Step 1の点群前処理の確認結果

### 2.1. Step 1の点群処理フロー

`env/point_cloud_utils.py`を確認した結果：

```python
def get_point_cloud(self, num_points=1024):
    # 1. PyBulletから深度画像を取得
    rgb, depth, view_matrix, proj_matrix = self.get_camera_image()
    
    # 2. 深度画像を3D点群に変換
    points = depth_image_to_point_cloud(...)
    
    # 3. 外れ値をフィルタリング
    points = filter_point_cloud(points, z_min=0.4, z_max=1.0)
    
    # 4. 正規化（単位球に）
    points, _, _ = normalize_point_cloud(points)
    
    # 5. 固定数の点をサンプリング
    points = sample_point_cloud(points, num_points)
```

**重要な発見**:
- Step 1では**1024点**をサンプリング（Phase 1は512点）
- `normalize_point_cloud`で**単位球に正規化**している
- この正規化は、Phase 1の訓練データと**同じ範囲**（[-1, 1]程度）になるはず

---

## 3. 根本原因の特定

### 3.1. 点の数の不一致

**Phase 1**: 512点  
**Step 1**: 1024点

FunctorFは点ごとに処理を行うため、点の数が異なっても動作するはず。しかし、これが問題の一因である可能性がある。

### 3.2. 形状の違い

**Phase 1の訓練データ**:
- 立方体: 内部が均一に埋まっている（`uniform(-1, 1)`）
- 円柱: 内部が埋まっている
- 球: 内部が埋まっている（体積サンプリング）

**Step 1のPyBullet点群**:
- 立方体、円柱、球: **表面のみ**（深度画像から生成）
- 内部は空洞

**これが最も可能性の高い根本原因である。**

### 3.3. なぜηが不変なのか？

Phase 1のF/Gは、**内部が埋まった形状**で訓練されている。しかし、Step 1では**表面のみの点群**を入力している。

F/Gから見ると、PyBulletの点群は：
- すべて「表面のみの点群」という共通の特徴を持つ
- 訓練分布から大きく外れている（out-of-distribution）
- F/Gは、訓練時に見たことのないパターンに対して、**一定の高い再構成誤差**を出力する

つまり、F/Gは「これは訓練データと違う」と判断し、すべての入力に対して同じ（高い）ηを出力している。

---

## 4. 検証実験の提案

### 4.1. 仮説

「Phase 1の訓練データ（内部が埋まった形状）とStep 1のPyBullet点群（表面のみ）の分布の違いが、ηの不変性の原因である」

### 4.2. 検証方法

以下の2つの実験を行う：

#### 実験A: Phase 1と同じ形式の点群でηを計算

Phase 1の`SyntheticAffordanceDataset`と同じ方法で点群を生成し、ηを計算する。

**期待される結果**: ηが形状ごとに異なる値を示す

#### 実験B: PyBulletの点群を「内部を埋める」ように修正

表面の点群から、内部を補間して埋めた点群を生成し、ηを計算する。

**期待される結果**: ηが物理的相互作用に対して変化する

---

## 5. 修正案

### 修正案1: Phase 1の訓練データを「表面のみ」に変更して再訓練

**メリット**:
- PyBulletの点群と訓練データの分布が一致する
- 物理シミュレーションの現実に即している（深度カメラは表面しか見えない）

**デメリット**:
- Phase 1を最初からやり直す必要がある（約1時間）
- 既存のチェックポイントが使えなくなる

### 修正案2: PyBulletの点群を「内部を埋める」ように修正

**メリット**:
- Phase 1のチェックポイントをそのまま使える
- 実装が比較的簡単

**デメリット**:
- 「内部を埋める」処理が恣意的になる可能性がある
- 物理的な意味が不明確

### 修正案3: 両方のアプローチを試す

**推奨**: まず修正案2で迅速に検証し、効果があれば修正案1で本格的に対応する

---

## 6. 次のアクション

### 優先度1: 検証実験Aを実行

Phase 1と同じ形式の点群でηを計算し、F/Gが正常に動作することを確認する。

### 優先度2: 修正案2を実装

PyBulletの点群を「内部を埋める」処理を実装し、Step 1を再実行する。

### 優先度3（条件付き）: 修正案1を実装

修正案2で効果が確認できた場合、Phase 1を「表面のみ」の点群で再訓練する。

---

## 7. 結論

**根本原因は、Phase 1の訓練データ（内部が埋まった形状）とStep 1のPyBullet点群（表面のみ）の分布の不一致である可能性が最も高い。**

この問題は、正規化の問題ではなく、**データの性質の違い**に起因する。F/Gは訓練分布外のデータに対して、一定の高いηを出力している。

次のステップとして、検証実験Aを実行し、この仮説を確認する。
