# 開発計画：Valenceの役割の実験的検証

**日付**: 2026-02-16

## 1. 背景と目的

2026年2月16日の議論とコードベースの再検証により、以下の重要な事実が明らかになった。

1.  **Phase 2 Slackの成功要因**: Slackの管理（η/εの保存）は、`L_aff`（アフォーダンス予測損失）という単一の外部目的によって達成された。
2.  **既存コンポーネントの役割**: `Priority`計算、`valence`更新、`coherence`、`uncertainty`といった内部信号は、現在の訓練ループにおいて**実質的に機能していなかった**（損失関数に影響を与えていない）。

この発見は、プロジェクトの理論的基盤を揺るがすものであり、同時に、よりシンプルで強力な実験設計への道を開くものである。

本計画の目的は、**「valenceが訓練を駆動する力として機能したとき、何が変わるか」**を厳密に検証することである。

## 2. 実験設計：Phase 2 Slackフレームワーク上での対照実験

すでに安定して動作しているPhase 2 Slackの枠組みをベースとし、変更点を最小限に抑えることで、`valence`の真の効果を測定する。

### 2.1 比較する3つの条件

| 条件 | 説明 | 目的 |
|:---|:---|:---|
| **条件1: ベースライン** | 現行のPhase 2 Slackを再現（`valence`更新なし） | 既存の結果を再現し、比較の基準点とする |
| **条件2: 内発的Valence (2/13)** | 2/13の知見に基づき、内発的報酬でValenceを駆動 | 2/13で観測されたValence成長を再現し、その効果を検証する（**本命**） |
| **条件3: 設計されたValence** | `Priority`計算（`coh × unc × val`）を有効化する | `valence`の使い方を人間が設計した場合の効果を検証する |

### 2.2 評価指標

- **Slack管理**: η（unit）とε（counit）の時系列変化。ベースラインと比較してどう変化するか。
- **タスク性能**: `L_aff`の収束速度と最終的な値。
- **内部状態**: `valence`の値の変化、`uncertainty`の変化。
- **創発的構造**: 条件2において、`valence`と他の指標（`η`, `ε`）の間にどのような相関が生まれるか。

## 3. 実装計画

### Step 1: コードベースのクリーンアップとリファクタリング

現在の理論と一致しない古い設計思想のコードを整理し、実験の見通しを良くする。

- **`priority.py`**: `valence`を考慮する部分を分離し、`priority_v2.py`（`coh × unc`）と`priority_v3.py`（`coh × unc × val`）に分割する。
- **`agent_c.py`**: 内部のロジックが複雑化しているため、条件2と条件3で必要なコンポーネントを明確に分離・整理する。
- **`valence_v2.py`**: `R_intrinsic`に基づく更新から、よりシンプルな「行動とSlack変化(Δη)の記憶」へと役割を明確化する。

### Step 2: 条件2（創発的Valence）の実装

これが最も重要なステップである。

1.  **`ValenceMemoryV3`の作成**: `valence_v2.py`をベースに、以下の機能を持つ新しいValenceモジュールを作成する。
    - **入力**: `action`, `Δη` (Slackの変化量)
    - **機能**: `(action, Δη)`のペアを記憶し、`valence`ベクトルを更新する。
    - **出力**: `valence`ベクトル

2.  **`AgentCV3`の作成**: `agent_c.py`をベースに、以下の変更を加えた新しいAgentモジュールを作成する。
    - **Priority計算モジュールを削除**する。
    - `coherence`と`uncertainty`をRSSMへの**観測入力**として直接渡す。
    - `ValenceMemoryV3`から出力された`valence`をRSSMの**状態更新**に直接入力する。

3.  **`train_phase2_condition2.py`の作成**: `train_phase2_slack.py`をコピーし、`AgentCV3`を使用するように変更する。

### Step 3: 条件3（設計されたValence）の実装

1.  **`valence_v2.py`の修正**: `alpha_curiosity`などのハイパーパラメータを外部から設定できるようにする。
2.  **`train_phase2_condition3.py`の作成**: `train_phase2_slack.py`をコピーし、訓練ループの開始時に`alpha_curiosity=1.0`（または適切な値）を設定して`valence`更新を有効化する。

### Step 4: 実験の実行と分析

1.  **条件1の再実行**: ベースラインとなる結果を再生成する。
2.  **条件2、3の実行**: それぞれ50エポック程度、同じデータセットで訓練を実行する。
3.  **結果の分析**: 上記の評価指標に基づき、3つの条件を比較分析するスクリプトを作成し、レポートとグラフを生成する。

## 4. ドキュメントの更新

実験結果に基づき、以下のドキュメントを更新または新規作成する。

- **`TODO.md`**: この新しい計画を反映させる。
- **`docs/theory/priority_and_valence_reconsidered.md`**: 実験結果のサマリーを追記する。
- **`experiments/phase2_valence_experiment/`**: 新しい実験ディレクトリを作成し、結果、分析スクリプト、最終レポートを格納する。

## 5. タイムライン

- **Day 1**: Step 1 (リファクタリング)
- **Day 2**: Step 2 (条件2の実装)
- **Day 3**: Step 3 (条件3の実装) & Step 4 (実験実行開始)
- **Day 4-5**: Step 4 (実験分析) & Step 5 (ドキュメント更新)

この計画は、現在の理論的混乱を解消し、プロジェクトをデータ駆動で前進させるための最も確実な道筋である。
