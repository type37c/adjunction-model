# Phase 1.5: F/Gの改修と再訓練 実験計画

**作成日:** 2026年2月19日  
**目的:** F/Gが物理的相互作用に対して意味のある信号（η）を出力するように改修・再訓練する

## 背景

Step 1の実験により、Phase 1で訓練されたF/Gの再構成誤差ηが以下の問題を抱えていることが判明した：

1. **視点変化に過敏**: ηは視点が変わると大きく変化するが、これは「アフォーダンス」ではなく「視点からの形状再構成」の難易度を反映している
2. **物理的相互作用への反応が鈍い**: オブジェクトを押す、倒す、回転させてもηはほとんど変化しない
3. **根本原因**: Phase 1の訓練データは静的な形状のみで、物理的相互作用を含まない

## Phase 1.5の目標

F/Gを改修し、**物理的相互作用を含むデータ**で再訓練することで、ηが以下の性質を持つようにする：

1. **行動の種類によってηが系統的に変化する**（例: 押す vs 倒す で異なるηパターン）
2. **視点変化への過敏性が低減する**（視点は補助的な情報であり、主要な信号ではない）
3. **アフォーダンスに関連する特徴を捉える**（例: 「倒れやすさ」「掴みやすさ」など）

## アーキテクチャの改修

### FunctorF_v2の設計

#### 改修1: 近傍構造の導入

**問題**: 現在のFunctorFは各点を独立にMLPに通すだけで、点と点の関係（局所的な幾何学）を捉えていない。

**解決策**: k近傍（k-NN）を用いて局所構造を考慮する。

```python
class FunctorF_v2(nn.Module):
    def __init__(self, input_dim=3, affordance_dim=32, goal_dim=16, k=16):
        # k: 近傍点の数（デフォルト16）
        self.k = k
        
        # 局所特徴抽出: 点の座標 + 近傍との相対位置
        self.local_encoder = nn.Sequential(
            nn.Linear(input_dim * 2, 64),
            nn.ReLU(),
            nn.Linear(64, 128),
            nn.ReLU()
        )
        
        # 目的による条件付け（FiLM変調）
        self.goal_to_gamma = nn.Linear(goal_dim, 128)
        self.goal_to_beta = nn.Linear(goal_dim, 128)
        
        # アフォーダンス表現への射影
        self.to_affordance = nn.Sequential(
            nn.Linear(128, affordance_dim),
            nn.ReLU()
        )
```

**哲学的根拠**: ハイデガーの「道具連関（Zeugzusammenhang）」— 道具は孤立して存在せず、常に他の道具との参照連関の中にある。同様に、点も孤立して処理すべきではなく、近傍との関係が重要。

#### 改修2: 目的条件付け

**問題**: 現在のF(x)は目的を考慮しない。しかし、アフォーダンスは目的に依存する（「飲む」なら取っ手がアフォーダンス、「投げる」なら重さがアフォーダンス）。

**解決策**: 目的ベクトルgを受け取り、FiLM変調で特徴を条件付ける。

```python
def forward(self, pos, goal=None):
    # ... 局所特徴の抽出 ...
    
    if goal is not None:
        gamma = self.goal_to_gamma(goal).unsqueeze(1)
        beta = self.goal_to_beta(goal).unsqueeze(1)
        features = gamma * features + beta
    
    affordances = self.to_affordance(features)
    return affordances
```

**哲学的根拠**: ハイデガー — 道具の存在は「〜のために（Um-zu）」によって構成される。目的がなければ、道具は単なる「眼前存在（Vorhandensein）」として現れるだけで、「手前存在（Zuhandensein）」としてのアフォーダンスは現れない。

### FunctorGの設計（変更なし）

FunctorGは当面変更しない。Phase 1のアーキテクチャをそのまま使用する。

## 訓練データの収集

### データ生成スクリプト

PyBulletで「形状 + 行動 → 結果」のデータを収集する。

#### オブジェクトの種類（5種類）
1. **Box**: 立方体（辺の長さ0.1m）
2. **Cylinder**: 円柱（半径0.05m、高さ0.1m）
3. **Sphere**: 球（半径0.05m）
4. **Cup**: カップ（Phase 1のデータセットから）
5. **Bowl**: ボウル（Phase 1のデータセットから）

#### 行動の種類（5種類）
1. **Push**: 水平方向に押す（力の大きさ: 10N、持続時間: 0.5s）
2. **Pull**: 水平方向に引く（力の大きさ: 10N、持続時間: 0.5s）
3. **Rotate**: 垂直軸周りに回転させる（トルク: 1Nm、持続時間: 0.5s）
4. **Lift**: 垂直方向に持ち上げる（力の大きさ: 15N、持続時間: 0.5s）
5. **Topple**: 側面を押して倒す（力の大きさ: 5N、持続時間: 0.3s）

#### データ収集の詳細
- **各組み合わせ**: 5オブジェクト × 5行動 = 25組み合わせ
- **各組み合わせのエピソード数**: 100エピソード
- **総エピソード数**: 2500エピソード
- **各エピソードの長さ**: 2秒（200タイムステップ、dt=0.01s）
- **記録するデータ**:
  - 初期点群（行動前）: (N, 3)
  - 行動の種類: one-hot vector (5,)
  - 最終点群（行動後）: (N, 3)
  - 軌跡（オプション）: (T, N, 3)

### データセットのフォーマット

```python
{
    'initial_pointcloud': torch.Tensor,  # (B, N, 3)
    'action_type': torch.Tensor,         # (B, 5) one-hot
    'final_pointcloud': torch.Tensor,    # (B, N, 3)
    'trajectory': torch.Tensor,          # (B, T, N, 3) オプション
}
```

## 訓練戦略

### 損失関数

```python
L = λ_recon · L_recon + λ_action · L_action
```

#### 再構成損失（L_recon）
Phase 1と同じ。初期点群と最終点群の両方で再構成誤差を計算。

```python
L_recon = ||x_initial - G(F(x_initial, a))||^2 + ||x_final - G(F(x_final, a))||^2
```

ここで、`a`は行動の種類（one-hotベクトル）。

#### 行動予測損失（L_action）
F(x_initial, a)の出力から、行動後の点群を予測する。

```python
# 簡易版: 平均プーリングしてMLPで予測
affordance_summary = F(x_initial, a).mean(dim=1)  # (B, affordance_dim)
predicted_final = action_predictor(affordance_summary)  # (B, N, 3)
L_action = ||x_final - predicted_final||^2
```

**意図**: F(x, a)が「行動aを適用したときの結果」を予測できるようになることで、アフォーダンスが物理的相互作用に関連する特徴を含むようになる。

### ハイパーパラメータ

| パラメータ | 値 | 備考 |
|---|---|---|
| バッチサイズ | 32 | |
| 学習率 | 1e-4 | Adam optimizer |
| エポック数 | 50 | 早期終了あり |
| λ_recon | 1.0 | Phase 1と同じ重み |
| λ_action | 0.5 | 初期値、調整可能 |
| k（近傍数） | 16 | |
| affordance_dim | 32 | Phase 1と同じ |
| goal_dim | 16 | 行動の種類（5次元）をembedding |

### 訓練の手順

1. **データ収集**: PyBulletで2500エピソードのデータを生成（推定時間: 1-2時間）
2. **データセットの作成**: HDF5またはPickleで保存
3. **Phase 1チェックポイントのロード**: FunctorF_v2の初期化にPhase 1の重みを使用（転移学習）
4. **訓練の実行**: 50エポック（推定時間: 2-3時間）
5. **チェックポイントの保存**: `phase1.5_best.pth`

## 評価指標

### 定量的指標

1. **再構成誤差（η）の変動係数（CV）**
   - Phase 1: CV ≈ 0.0465
   - 目標: CV > 0.10（より大きな変動）

2. **行動種類による差**
   - ANOVA F統計量: 行動の種類がηに有意な影響を与えるか
   - 目標: p < 0.01

3. **視点変化 vs 物理的相互作用の影響比**
   - Phase 1: 視点変化の影響 >> 物理的相互作用の影響
   - 目標: 視点変化の影響 ≤ 物理的相互作用の影響

4. **行動予測精度**
   - 行動後の点群を予測する精度（MSE）
   - 目標: MSE < 0.01

### 定性的評価

1. **ηのヒートマップ**: オブジェクト × 行動のマトリックスでηを可視化
2. **アフォーダンス表現の可視化**: PCAまたはt-SNEで次元削減し、行動の種類でクラスタリングされるか確認
3. **失敗ケースの分析**: ηが変化しないケース、予測が外れるケースを詳細に分析

## 実験の実行計画

### タイムライン

| ステップ | 内容 | 推定時間 |
|---|---|---|
| 1 | FunctorF_v2の実装とテスト | 2時間 |
| 2 | データ収集スクリプトの実装 | 2時間 |
| 3 | データ収集の実行 | 1-2時間 |
| 4 | 訓練スクリプトの実装 | 1時間 |
| 5 | 訓練の実行 | 2-3時間 |
| 6 | Step 1の再実行（評価） | 30分 |
| 7 | 結果の分析とドキュメント化 | 2時間 |
| **合計** | | **10-12時間** |

### 成功基準

Phase 1.5は、以下の条件を満たせば成功とみなす：

1. **ηの変動係数が0.10以上**（Phase 1の2倍以上）
2. **行動の種類によるηの差が統計的に有意**（ANOVA p < 0.01）
3. **視点変化の影響が物理的相互作用の影響以下**

これらの条件が満たされない場合、以下の対応を検討する：

- λ_actionの増加（物理的相互作用の重要性を強調）
- データ収集の多様化（より多様な行動、より多様なオブジェクト）
- FunctorF_v2のアーキテクチャの再検討（より深いネットワーク、異なる近傍構造）

## 次のステップ

Phase 1.5が成功した場合、Phase 2.1に進む：

1. **Module M（目的機構）の実装**
2. **Agent CとF/Gの統合**
3. **end-to-end訓練**

Phase 1.5が失敗した場合、Phase 1の訓練目標そのものを見直す必要がある。
