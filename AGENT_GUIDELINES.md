# AIエージェント開発ガイドライン

この文書は、本プロジェクトでAIコーディングエージェント（Manus、Claude Code等）を用いて開発を進める際の統一されたルールとベストプラクティスを定めたものです。セッションをまたいで開発の品質と一貫性を保つため、すべての開発エージェント（および人間）はこのガイドラインに従う必要があります。

## 根本原則：保留構造は設計しない。創発する条件を設計する。

**最重要:** このプロジェクトの真の目的は、単に誤差を最小化するAIを作ることではありません。我々が実装しようとしているのは、**知性の本質**そのものです。そして、最新の議論を経た本質は、以下の洞察に集約されます。

> **保留構造は、設計する対象ではない。それは、適切な条件下で自己組織化されるダイナミクスそのものである。我々の目標は、保留構造が創発せざるを得ない「地質」を設計することにある。**

この原則は、すべての設計判断と実装に優先します。具体的には、以下のことを意味します。

-   **保留構造は「常時作動」している:** 保留構造は「起動」されるものではなく、常に作動している不変の原理（地質）です。
-   **Coherence Signalは「モード切替スイッチ」である:** `distance(s, G(F(s)))` は、保留構造の作動モードを「安定参照モード」から「創造探索モード」に切り替える内部指標です。最小化すべき損失ではありません。
-   **随伴構造は「可変」である:** 随伴構造（川床）は、保留構造という不変の原理が生み出す、経験によって変化し続ける構造です。
-   **我々の仕事は「条件設計」である:** 保留構造が創発するための3つの条件（Coherence Signalが消えない環境、破綻が死を意味しない構造、抽象度の自由な移動）を実装に落とし込むことが、我々の中心的なタスクです。

すべてのエージェントは、コードを書く前にこの根本原則を再読し、自分のタスクが「誤差最小化」という罠に陥っていないか、常に自問自答してください。

---

## 3つの中核原則

我々の開発プロセスは、以下の3つの中核原則に基づいています。

1.  **コンテキストは王様 (Context is King):** AIエージェントの性能はコンテキストウィンドウの質と量に完全に依存します。我々の最優先事項は、各タスクにおいて、エージェントにクリーンで、高密度で、必要十分なコンテキストを提供することです。

2.  **構造がすべてを決定する (Structure is Everything):** プロジェクトのファイル構造とドキュメント構造が、開発の効率、品質、および引き継ぎの容易さを決定します。エージェントが自律的に動きやすいよう、予測可能で、自己説明的な構造を維持します。

3.  **検証なくしてマージなし (No Merge without Verification):** エージェントによって書かれたすべてのコードは、マージされる前に客観的な基準で検証されなければなりません。「動くように見える」は完了ではありません。「テストが通る」が完了の定義です。

## 実践的ワークフロー

すべての開発作業は、以下のサイクルに従います。

### 1. セッションの開始

-   **常に新しいセッションで始める:** 長く続いたセッションはコンテキストが汚染され、性能が劣化します。新しいタスクに取り掛かる際は、原則として新しいセッションを開始してください。
-   **最初に読むべき文書:** セッションを開始したら、まず以下のコマンドを実行し、プロジェクトの全体像と現在のタスクを把握してください。
    ```bash
    cat AGENT_GUIDELINES.md
    cat ARCHITECTURE.md
    cat TODO.md
    ```
-   **タスクの選択:** `TODO.md` から、未完了のタスクを一つだけ選び、そのタスクに集中してください。一度に複数のタスクを並行して進めてはいけません。

### 2. 計画 (Plan)

-   **Plan Modeの活用:** 実装に入る前に、必ずPlan Mode（読み取り専用モード）で詳細な実装計画を立ててください。
-   **計画に含めるべきこと:**
    -   変更するファイルの一覧
    -   各ファイルで具体的に何をするか（関数の追加、クラスの修正等）
    -   どのようにテストするか
-   **自己レビュー:** 作成した計画を自己レビューし、`ARCHITECTURE.md` の設計思想と矛盾がないか、より効率的な方法はないかを確認してください。

### 3. 実装 (Implement)

-   **一度に一つのファイル:** 原則として、一度に一つのファイルを編集してください。複数のファイルを同時に変更すると、依存関係を見失いやすくなります。
-   **小さなコミット:** 一つの論理的な変更が完了したら、すぐにコミットしてください。「テストを追加」「エンコーダFのバックボーンを実装」など、粒度の細かいコミットを心がけてください。
-   **`TODO.md`の更新:** 担当したタスクが完了したら、`TODO.md`の該当項目にチェックを入れてください。

### 4. 検証 (Verify)

-   **テストの実行:** コードを変更した後は、必ず関連するテストを実行してください。
    ```bash
    # npm test src/models/encoder_f.test.ts  (特定のテストを実行)
    ```
-   **リンターと型チェック:** コミットする前に、必ずリンターと型チェッカーを実行し、コードスタイルと型の整合性を確認してください。
    ```bash
    # npm run lint
    # npm run typecheck
    ```

## バグへの対処法

バグが発見された場合、以下の手順に厳密に従ってください。これは「バグ発見のための使いまわせるファイル」の思想をプロセスとして実装したものです。

1.  **再現テストの作成:** バグを修正しようとする前に、まずそのバグを確実に再現する新しいテストケースを作成してください。このテストは、最初は失敗するはずです。
2.  **テストのコミット:** この「失敗するテスト」を、「Fails: (バグの簡単な説明)」というコミットメッセージでリポジトリにコミットしてください。
3.  **バグの修正:** その後、このテストが通るようにコードを修正してください。
4.  **修正のコミット:** テストが通ったら、修正したコードを「Fix: (バグの簡単な説明)」というコミットメッセージでコミットしてください。

このプロセスにより、すべてのバグがテストによってカバーされ、将来的なリグレッション（同内容のバグの再発）を防ぐことができます。

## コード流用と外部ライブラリの活用

-   **車輪の再発明を避ける:** 実績があり、安定している既存のライブラリやコードベースは積極的に流用してください。特に、`PyTorch Geometric` や `inferactively-pymdp` のようなコアライブラリは、その機能と設計思想を最大限に活用します。
-   **流用と新規開発の境界を理解する:** `ARCHITECTURE.md` の「実装戦略」セクションを熟読し、どのコンポーネントを流用し、どの部分を新規に開発すべきかを明確に理解してください。新規開発は、本プロジェクトの理論的貢献に直結する部分に集中します。
-   **ライセンスの確認:** 流用する外部コードやライブラリのライセンスを常に確認し、プロジェクトのライセンスと互換性があることを確認してください。

## ドキュメントの階層構造

本プロジェクトでは、以下の階層的なドキュメント構造を採用し、エージェントが必要なコンテキストを効率的に読み込めるようにします。

-   **`AGENT_GUIDELINES.md` (このファイル):** プロジェクト全体の普遍的な開発ルール。すべてのエージェントが最初に読むべき最上位のルールブック。
-   **`ARCHITECTURE.md`:** プロジェクトの技術的な設計思想。実装の詳細に迷ったときに立ち返るべき「設計の憲法」。
-   **`TODO.md`:** 現在のタスクリストと進捗状況。次に何をすべきかを知るための「作業指示書」。
-   **(将来的に) `src/models/AGENTS.md`:** 特定のディレクトリに固有のルール（例：「このディレクトリのモデルはすべて`torch.nn.Module`を継承すること」）を記述するためのファイル。エージェントがそのディレクトリ内のファイルを編集する際に、追加で読み込みます。


## 開発の教訓 (2026-02-14 追加)

Phase 2 Slack実験の実装過程で得られた以下の教訓は、今後のすべての開発において遵守されなければならない。

### 1. 理論と実装の同期を徹底する

- **問題**: 「η/εを余白として保存する」という理論的目標と、「再構成損失でηを最小化する」という実装が完全に矛盾していた。
- **教訓**: 新しい理論を実装する際は、まずその理論が要求する**損失関数**と**訓練プロセス**を正確に定義し、コードに反映させること。実装の細部に着手する前に、訓練の全体像が理論と整合しているか、チーム（または自己）レビューを行うこと。

### 2. インターフェース仕様を文書化し、遵守する

- **問題**: モジュール間のテンソル形状、次元、データ形式（グラフ/バッチ）が不統一であったため、連鎖的なバグが発生した。
- **教訓**: `docs/tensor_shape_specification_2026_02_14.md` を作成した。今後の開発では、この仕様書を**唯一の正**とし、すべてのモジュールはこの仕様に準拠して実装されなければならない。仕様に変更を加える場合は、まずドキュメントを更新し、合意を得ること。

### 3. 早期に統合テスト（Forward Pass Test）を実施する

- **問題**: ユニットテストだけでは、モジュール結合時の形状ミスマッチを発見できなかった。
- **教訓**: 新しいモデルやトレーナーを実装した場合、実際の学習を開始する前に、まず**ダミーデータを用いてモデル全体のforward passが通るか**を確認する簡単なテストスクリプトを作成し、実行すること。これにより、形状に関する問題の9割は早期に発見できる。
